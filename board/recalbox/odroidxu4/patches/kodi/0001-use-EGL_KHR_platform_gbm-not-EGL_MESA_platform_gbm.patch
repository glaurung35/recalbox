diff --git a/xbmc/windowing/Resolution.cpp b/xbmc/windowing/Resolution.cpp
index 7f1e1c2ed1..dfed35bf92 100644
--- a/xbmc/windowing/Resolution.cpp
+++ b/xbmc/windowing/Resolution.cpp
@@ -69,6 +69,8 @@ float RESOLUTION_INFO::DisplayRatio() const
 
 RESOLUTION CResolutionUtils::ChooseBestResolution(float fps, int width, int height, bool is3D)
 {
+  fps = static_cast<float>(std::round(fps));
+
   RESOLUTION res = CServiceBroker::GetWinSystem()->GetGfxContext().GetVideoResolution();
   float weight;
 
diff --git a/xbmc/windowing/gbm/GBMUtils.cpp b/xbmc/windowing/gbm/GBMUtils.cpp
index cf6ee7df4a..edc47e349e 100644
--- a/xbmc/windowing/gbm/GBMUtils.cpp
+++ b/xbmc/windowing/gbm/GBMUtils.cpp
@@ -74,24 +74,29 @@ CGBMUtils::CGBMDevice::CGBMSurface::CGBMSurface(gbm_surface* surface) : m_surfac
 {
 }
 
+#define MAX_SURFACE_BUFFERS 3
 CGBMUtils::CGBMDevice::CGBMSurface::CGBMSurfaceBuffer* CGBMUtils::CGBMDevice::CGBMSurface::
     LockFrontBuffer()
 {
-  m_buffers.emplace(std::make_unique<CGBMSurfaceBuffer>(m_surface));
 
-  if (!static_cast<bool>(gbm_surface_has_free_buffers(m_surface)))
+ /* Fix for ODROID XU4, gbm_surface_has_free_buffers doesn't seem to report if there
+  * are no buffers available instead GEM buffers are running out, so we manually empty
+  * the buffers here for a maximum of three
+  */
+  std::call_once(
+     flag, [this]() { CLog::Log(LOGDEBUG, "CGBMUtils - using {} buffers", MAX_SURFACE_BUFFERS); });
+
+  if (m_buffers.size() >= MAX_SURFACE_BUFFERS)
   {
-    /*
-     * We want to use call_once here because we want it to be logged the first time that
-     * we have to release buffers. This means that the maximum amount of buffers had been reached.
-     * For mesa this should be 4 buffers but it may vary accross other implementations.
-     */
-    std::call_once(
-        flag, [this]() { CLog::Log(LOGDEBUG, "CGBMUtils - using {} buffers", m_buffers.size()); });
-
-    m_buffers.pop();
+      while (!m_buffers.empty())
+      {
+        m_buffers.front();
+        m_buffers.pop();
+      }
   }
 
+  m_buffers.emplace(std::make_unique<CGBMSurfaceBuffer>(m_surface));
+
   return m_buffers.back().get();
 }
 
diff --git a/xbmc/windowing/gbm/WinSystemGbmEGLContext.cpp b/xbmc/windowing/gbm/WinSystemGbmEGLContext.cpp
index d8d775dcad..21efc02d34 100644
--- a/xbmc/windowing/gbm/WinSystemGbmEGLContext.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbmEGLContext.cpp
@@ -23,7 +23,7 @@ bool CWinSystemGbmEGLContext::InitWindowSystemEGL(EGLint renderableType, EGLint
     return false;
   }
 
-  if (!m_eglContext.CreatePlatformDisplay(m_GBM->GetDevice()->Get(), m_GBM->GetDevice()->Get()))
+  if (!m_eglContext.CreatePlatformDisplay(m_GBM->GetDevice()->Get(), reinterpret_cast<EGLNativeDisplayType>(m_GBM->GetDevice()->Get())))
   {
     return false;
   }
diff --git a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
index d07092ba78..bfdcf14f1f 100644
--- a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
@@ -34,7 +34,7 @@
 using namespace KODI::WINDOWING::GBM;
 
 CWinSystemGbmGLESContext::CWinSystemGbmGLESContext()
-: CWinSystemGbmEGLContext(EGL_PLATFORM_GBM_MESA, "EGL_MESA_platform_gbm")
+: CWinSystemGbmEGLContext(EGL_PLATFORM_GBM_MESA, "EGL_KHR_platform_gbm")
 {}
 
 void CWinSystemGbmGLESContext::Register()
diff --git a/xbmc/windowing/gbm/drm/DRMUtils.cpp b/xbmc/windowing/gbm/drm/DRMUtils.cpp
index 5593ce086b..59e0f65f6e 100644
--- a/xbmc/windowing/gbm/drm/DRMUtils.cpp
+++ b/xbmc/windowing/gbm/drm/DRMUtils.cpp
@@ -184,7 +184,7 @@ bool CDRMUtils::FindPlanes()
     auto videoPlane = std::find_if(m_planes.begin(), m_planes.end(), [&i](auto& plane) {
       if (plane->GetPossibleCrtcs() & (1 << i))
       {
-        return plane->SupportsFormat(DRM_FORMAT_NV12);
+        return (plane->SupportsFormat(DRM_FORMAT_NV12) || plane->SupportsFormat(DRM_FORMAT_XRGB8888));
       }
       return false;
     });
