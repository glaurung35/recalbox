MRFIXIT: this reverts a problem commit in the core that causes segfaults

index 14e8c955..b501281b 100644
diff --git a/doc/emuwiki-api-doc/Mupen64Plus-v2.0-Core-Front-End.mediawiki b/doc/emuwiki-api-doc/Mupen64Plus-v2.0-Core-Front-End.mediawiki
--- a/doc/emuwiki-api-doc/Mupen64Plus-v2.0-Core-Front-End.mediawiki
+++ b/doc/emuwiki-api-doc/Mupen64Plus-v2.0-Core-Front-End.mediawiki
@@ -187,7 +187,7 @@ Most libmupen64plus functions return an <tt>m64p_error</tt> return code, which i
 |The emulator must be currently running or paused.
 |-
 |M64CMD_SET_MEDIA_LOADER
+|This command allow frontends to register their media (such as GameBoy cartridge) loading functions. These functions will be called appropriately by the core at startup and when a new media is inserted.
-|This command allow frontends to register their media (such as GameBoy cartridge or 64DD disk) loading functions. These functions will be called appropriately by the core at startup and when a new media is inserted.
 |'''<tt>ParamInt</tt>''' must be sizeof(m64p_media_loader).'''<br /><tt>ParamPtr</tt>'''A pointer to the m64p_media_loader to register, cannot be NULL.
 |None
 |}
diff --git a/doc/emuwiki-api-doc/Mupen64Plus-v2.0-headers.mediawiki b/doc/emuwiki-api-doc/Mupen64Plus-v2.0-headers.mediawiki
index 6d64f640..c2f3f97e 100644
--- a/doc/emuwiki-api-doc/Mupen64Plus-v2.0-headers.mediawiki
+++ b/doc/emuwiki-api-doc/Mupen64Plus-v2.0-headers.mediawiki
@@ -160,20 +160,6 @@
    * Empty or NULL string results in the core generating a default save file with empty content.
    */
   char* (*get_gb_cart_ram)(void* cb_data, int controller_num);
-
-  /* Allow the frontend to specify the DD IPL ROM file to load
-   * cb_data: points to frontend-defined callback data.
-   * Returns a NULL-terminated string owned by the core specifying the DD IPL ROM filename to load
-   * Empty or NULL string results in disabled 64DD.
-   */
-  char* (*get_dd_rom)(void* cb_data);
-
-  /* Allow the frontend to specify the DD disk file to load
-   * cb_data: points to frontend-defined callback data.
-   * Returns a NULL-terminated string owned by the core specifying the DD disk filename to load
-   * Empty or NULL string results in no DD disk being loaded (eg. empty disk drive).
-   */
-  char* (*get_dd_disk)(void* cb_data);
  } m64p_media_loader;
 
  /* ----------------------------------------- */
diff --git a/projects/unix/Makefile b/projects/unix/Makefile
index fb634f85..6a5515dc 100755
--- a/projects/unix/Makefile
+++ b/projects/unix/Makefile
@@ -456,7 +456,6 @@ SOURCE = \
     $(SRCDIR)/device/controllers/paks/mempak.c \
     $(SRCDIR)/device/controllers/paks/rumblepak.c \
     $(SRCDIR)/device/controllers/paks/transferpak.c \
-    $(SRCDIR)/device/dd/dd_controller.c \
     $(SRCDIR)/device/device.c \
     $(SRCDIR)/device/gb/gb_cart.c \
     $(SRCDIR)/device/gb/mbc3_rtc.c \
diff --git a/src/api/m64p_types.h b/src/api/m64p_types.h
index 83c287cb..36a70710 100644
--- a/src/api/m64p_types.h
+++ b/src/api/m64p_types.h
@@ -184,20 +184,6 @@ typedef struct {
    * Empty or NULL string results in the core generating a default save file with empty content.
    */
   char* (*get_gb_cart_ram)(void* cb_data, int controller_num);
-
-  /* Allow the frontend to specify the DD IPL ROM file to load
-   * cb_data: points to frontend-defined callback data.
-   * Returns a NULL-terminated string owned by the core specifying the DD IPL ROM filename to load
-   * Empty or NULL string results in disabled 64DD.
-   */
-  char* (*get_dd_rom)(void* cb_data);
-
-  /* Allow the frontend to specify the DD disk file to load
-   * cb_data: points to frontend-defined callback data.
-   * Returns a NULL-terminated string owned by the core specifying the DD disk filename to load
-   * Empty or NULL string results in no DD disk being loaded (eg. empty disk drive).
-   */
-  char* (*get_dd_disk)(void* cb_data);
 } m64p_media_loader;
 
 /* ----------------------------------------- */
diff --git a/src/backends/file_storage.c b/src/backends/file_storage.c
index 0280b21d..b153311c 100644
--- a/src/backends/file_storage.c
+++ b/src/backends/file_storage.c
@@ -26,7 +26,6 @@
 #include "api/callbacks.h"
 #include "api/m64p_types.h"
 #include "backends/api/storage_backend.h"
-#include "device/dd/dd_controller.h"
 #include "main/util.h"
 
 int open_file_storage(struct file_storage* fstorage, size_t size, const char* filename)
@@ -103,36 +102,6 @@ static void file_storage_parent_save(void* storage)
     file_storage_save(fstorage);
 }
 
-static void file_storage_dd_sdk_dump_save(void* storage)
-{
-    static uint8_t sdk_buffer[SDK_FORMAT_DUMP_SIZE];
-    struct file_storage* fstorage = (struct file_storage*)storage;
-
-    /* XXX: for now, don't overwrite the original file, because we don't want to corrupt dumps... */
-    char* filename = formatstr("%s.save", fstorage->filename);
-    if (filename == NULL) {
-        DebugMessage(M64MSG_ERROR, "Failed to allocate memory for sdk_dump filename");
-        return;
-    }
-
-    dd_convert_to_sdk(fstorage->data, sdk_buffer);
-
-    switch(write_to_file(filename, sdk_buffer, SDK_FORMAT_DUMP_SIZE))
-    {
-    case file_open_error:
-        DebugMessage(M64MSG_WARNING, "couldn't open storage file '%s' for writing", fstorage->filename);
-        break;
-    case file_write_error:
-        DebugMessage(M64MSG_WARNING, "failed to write storage file '%s'", fstorage->filename);
-        break;
-    default:
-        break;
-    }
-
-    free(filename);
-}
-
-
 
 const struct storage_backend_interface g_ifile_storage =
 {
@@ -156,9 +125,3 @@ const struct storage_backend_interface g_isubfile_storage =
     file_storage_parent_save
 };
 
-const struct storage_backend_interface g_ifile_storage_dd_sdk_dump =
-{
-    file_storage_data,
-    file_storage_size,
-    file_storage_dd_sdk_dump_save
-};
diff --git a/src/backends/file_storage.h b/src/backends/file_storage.h
index d31f7b23..f5edcdc9 100644
--- a/src/backends/file_storage.h
+++ b/src/backends/file_storage.h
@@ -40,6 +40,5 @@ void close_file_storage(struct file_storage* storage);
 extern const struct storage_backend_interface g_ifile_storage;
 extern const struct storage_backend_interface g_ifile_storage_ro;
 extern const struct storage_backend_interface g_isubfile_storage;
-extern const struct storage_backend_interface g_ifile_storage_dd_sdk_dump;
 
 #endif
diff --git a/src/device/device.c b/src/device/device.c
index 7909e83f..9aa8c0e5 100644
--- a/src/device/device.c
+++ b/src/device/device.c
@@ -46,7 +46,18 @@ static void write_open_bus(void* opaque, uint32_t address, uint32_t value, uint3
 {
 }
 
+static unsigned int dd_dom_dma_read(void* opaque, const uint8_t* dram, uint32_t dram_addr, uint32_t cart_addr, uint32_t length)
+{
+    return /* length / 8 */0x1000;
+}
+
+static unsigned int dd_dom_dma_write(void* opaque, uint8_t* dram, uint32_t dram_addr, uint32_t cart_addr, uint32_t length)
+{
+    return /* length / 8 */0x1000;
+}
+
+
+static void get_pi_dma_handler(struct device* dev, uint32_t address, void** opaque, const struct pi_dma_handler** handler)
-static void get_pi_dma_handler(struct cart* cart, struct dd_controller* dd, uint32_t address, void** opaque, const struct pi_dma_handler** handler)
 {
 #define RW(o, x) \
     do { \
@@ -58,21 +69,21 @@ static void get_pi_dma_handler(struct device* dev, uint32_t address, void** opaq
     if (address >= MM_CART_ROM) {
         if (address >= MM_CART_DOM3) {
             /* 0x1fd00000 - 0x7fffffff : dom3 addr2, cart rom (Paper Mario (U)) ??? */
+            RW(&dev->cart, cart_dom3);
-            RW(cart, cart_dom3);
         }
         else {
             /* 0x10000000 - 0x1fbfffff : dom1 addr2, cart rom */
+            RW(&dev->cart.cart_rom, cart_rom);
-            RW(&cart->cart_rom, cart_rom);
         }
     }
     else if (address >= MM_DOM2_ADDR2) {
         /* 0x08000000 - 0x0fffffff : dom2 addr2, cart save */
+        RW(&dev->cart, cart_dom2);
-        RW(cart, cart_dom2);
     }
     else if (address >= MM_DOM2_ADDR1) {
         /* 0x05000000 - 0x05ffffff : dom2 addr1, dd buffers */
         /* 0x06000000 - 0x07ffffff : dom1 addr1, dd rom */
+        RW(NULL, dd_dom);
-        RW(dd, dd_dom);
     }
 #undef RW
 }
@@ -103,11 +114,7 @@ void init_device(struct device* dev,
     void* eeprom_storage, const struct storage_backend_interface* ieeprom_storage,
     uint32_t flashram_type,
     void* flashram_storage, const struct storage_backend_interface* iflashram_storage,
+    void* sram_storage, const struct storage_backend_interface* isram_storage)
-    void* sram_storage, const struct storage_backend_interface* isram_storage,
-    /* dd */
-    void* dd_rtc_clock, const struct clock_backend_interface* dd_rtc_iclock,
-    size_t dd_rom_size,
-    void* dd_disk, const struct storage_backend_interface* dd_idisk)
 {
     struct interrupt_handler interrupt_handlers[] = {
         { &dev->vi,        vi_vertical_interrupt_event }, /* VI */
@@ -145,25 +145,11 @@
         { A(MM_PI_REGS, 0xffff), M64P_MEM_PI, { &dev->pi, RW(pi_regs) } },
         { A(MM_RI_REGS, 0xffff), M64P_MEM_RI, { &dev->ri, RW(ri_regs) } },
         { A(MM_SI_REGS, 0xffff), M64P_MEM_SI, { &dev->si, RW(si_regs) } },
-        { A(MM_DOM2_ADDR1, 0xffffff), M64P_MEM_NOTHING, { NULL, RW(open_bus) } },
-        { A(MM_DD_ROM, 0x1ffffff), M64P_MEM_NOTHING, { NULL, RW(open_bus) } },
         { A(MM_DOM2_ADDR2, 0x1ffff), M64P_MEM_FLASHRAMSTAT, { &dev->cart, RW(cart_dom2)  } },
         { A(MM_CART_ROM, rom_size-1), M64P_MEM_ROM, { &dev->cart.cart_rom, RW(cart_rom) } },
         { A(MM_PIF_MEM, 0xffff), M64P_MEM_PIF, { &dev->pif, RW(pif_ram) } }
     };
 
-    /* init and map DD if present */
-    if (dd_rom_size > 0) {
-        mappings[14] = (struct mem_mapping){ A(MM_DOM2_ADDR1, 0xffffff), M64P_MEM_NOTHING, { &dev->dd, RW(dd_regs) } };
-        mappings[15] = (struct mem_mapping){ A(MM_DD_ROM, dd_rom_size-1), M64P_MEM_NOTHING, { &dev->dd, RW(dd_rom) } };
-
-        init_dd(&dev->dd,
-                dd_rtc_clock, dd_rtc_iclock,
-                mem_base_u32(base, MM_DD_ROM), dd_rom_size,
-                dd_disk, dd_idisk,
-                &dev->r4300);
-    }
-
     struct mem_handler dbg_handler = { &dev->r4300, RW(with_bp_checks) };
 #undef A
 #undef R
@@ -181,26 +174,16 @@ void init_device(struct device* dev,
     init_ai(&dev->ai, &dev->mi, &dev->ri, &dev->vi, aout, iaout);
     init_mi(&dev->mi, &dev->r4300);
     init_pi(&dev->pi,
+            dev, get_pi_dma_handler,
-            get_pi_dma_handler,
-            &dev->cart, &dev->dd,
             &dev->mi, &dev->ri, &dev->dp);
     init_ri(&dev->ri, &dev->rdram);
     init_si(&dev->si, si_dma_duration, &dev->mi, &dev->pif, &dev->ri);
     init_vi(&dev->vi, vi_clock, expected_refresh_rate, &dev->mi, &dev->dp);
 
-    /* FIXME: should boot on cart, unless only a disk is present, but having no cart is not yet supported by ui/core,
-     * so use another way of selecting boot device:
-     * use CART unless DD is plugged and the plugged CART is not a combo media (cart+disk).
-     */
-    uint8_t media = *((uint8_t*)mem_base_u32(base, MM_CART_ROM) + (0x3b ^ S8));
-    uint32_t rom_base = (dd_rom_size > 0 && media != 'C')
-        ? MM_DD_ROM
-        : MM_CART_ROM;
-
     init_pif(&dev->pif,
         (uint8_t*)mem_base_u32(base, MM_PIF_MEM),
         jbds, ijbds,
+        (uint8_t*)mem_base_u32(base, MM_CART_ROM + 0x40),
-        (uint8_t*)mem_base_u32(base, rom_base) + 0x40,
         &dev->r4300);
 
     init_cart(&dev->cart,
@@ -240,10 +223,6 @@ void poweron_device(struct device* dev)
             channel->ijbd->poweron(channel->jbd);
         }
     }
-
-    if (dev->dd.rom != NULL) {
-        poweron_dd(&dev->dd);
-    }
 }
 
 void run_device(struct device* dev)
diff --git a/src/device/device.h b/src/device/device.h
index f907f077..0fb6b0d4 100644
--- a/src/device/device.h
+++ b/src/device/device.h
@@ -30,7 +30,6 @@
 #include "controllers/paks/mempak.h"
 #include "controllers/paks/rumblepak.h"
 #include "controllers/paks/transferpak.h"
-#include "dd/dd_controller.h"
 #include "gb/gb_cart.h"
 #include "memory/memory.h"
 #include "pif/pif.h"
@@ -69,10 +68,6 @@ enum { GAME_CONTROLLERS_COUNT = 4 };
 #define MM_SI_REGS          UINT32_C(0x04800000)
 
 #define MM_DOM2_ADDR1       UINT32_C(0x05000000)
-#define MM_DD_C2S_BUFFER    UINT32_C(0x05000000)
-#define MM_DD_DS_BUFFER     UINT32_C(0x05000400)
-#define MM_DD_REGS          UINT32_C(0x05000500)
-#define MM_DD_MS_RAM        UINT32_C(0x05000580)
 #define MM_DD_ROM           UINT32_C(0x06000000)
 
 #define MM_DOM2_ADDR2       UINT32_C(0x08000000)
@@ -105,8 +100,6 @@ struct device
     struct gb_cart gb_carts[GAME_CONTROLLERS_COUNT];
 
     struct cart cart;
-
-    struct dd_controller dd;
 };
 
 /* Setup device "static" properties.  */
@@ -136,11 +129,7 @@ void init_device(struct device* dev,
     void* eeprom_storage, const struct storage_backend_interface* ieeprom_storage,
     uint32_t flashram_type,
     void* flashram_storage, const struct storage_backend_interface* iflashram_storage,
+    void* sram_storage, const struct storage_backend_interface* isram_storage);
-    void* sram_storage, const struct storage_backend_interface* isram_storage,
-    /* dd */
-    void* dd_rtc_clock, const struct clock_backend_interface* dd_rtc_iclock,
-    size_t dd_rom_size,
-    void* dd_disk, const struct storage_backend_interface* dd_idisk);
 
 /* Setup device such that it's state is
  * what it should be after power on.
diff --git a/src/device/pif/cic.c b/src/device/pif/cic.c
index b994dac7..bb82f5c8 100644
--- a/src/device/pif/cic.c
+++ b/src/device/pif/cic.c
@@ -45,8 +45,7 @@ void init_cic_using_ipl3(struct cic* cic, const void* ipl3)
         { "X103", CIC_X103, 0x78 },
         { "X105", CIC_X105, 0x91 },
         { "X106", CIC_X106, 0x85 },
+        { "5167", CIC_5167, 0xdd }
-        { "5167", CIC_5167, 0xdd },
-        { "8303", CIC_8303, 0xdd }
     };
 
     for (i = 0; i < 0xfc0/4; i++)
@@ -65,7 +64,6 @@ void init_cic_using_ipl3(struct cic* cic, const void* ipl3)
         case UINT64_C(0x000000D6D5BE5580): i = 5; break; /* CIC_X106 */
         case UINT64_C(0x000001053BC19870): i = 6; break; /* CIC 5167 */
         case UINT64_C(0x000000A5F80BF620): i = 0; break; /* CIC 5101 */
-        case UINT64_C(0x000000D2E53EF008): i = 7; break; /* CIC 8303 */
     }
 
     memcpy(cic, &cics[i], sizeof(*cic));
diff --git a/src/device/pif/cic.h b/src/device/pif/cic.h
index d7160073..ebe3d975 100644
--- a/src/device/pif/cic.h
+++ b/src/device/pif/cic.h
@@ -30,8 +30,7 @@ enum cic_version
     CIC_X105,
     CIC_X106,
     CIC_5101,
+    CIC_5167
-    CIC_5167,
-    CIC_8303
 };
 
 struct cic
diff --git a/src/device/pif/pif.c b/src/device/pif/pif.c
index 6a492694..21cda056 100644
--- a/src/device/pif/pif.c
+++ b/src/device/pif/pif.c
@@ -146,7 +146,7 @@ void reset_pif(struct pif* pif, unsigned int reset_type)
     size_t i;
 
     /* HACK: for allowing pifbootrom execution */
+    unsigned int rom_type = 0;
-    unsigned int rom_type = (pif->cic.version == CIC_8303) ? 1 : 0;
     unsigned int s7 = 0;
 
     /* 0:ColdReset, 1:NMI */
diff --git a/src/device/r4300/r4300_core.h b/src/device/r4300/r4300_core.h
index 123009be..43880e3c 100644
--- a/src/device/r4300/r4300_core.h
+++ b/src/device/r4300/r4300_core.h
@@ -246,6 +246,7 @@ int r4300_write_aligned_dword(struct r4300_core* r4300, uint32_t address, uint64
  */
 void invalidate_r4300_cached_code(struct r4300_core* r4300, uint32_t address, size_t size);
 
+
 /* Jump to the given address. This works for all r4300 emulator, but is slower.
  * Use this for common code which can be executed from any r4300 emulator. */
 void generic_jump_to(struct r4300_core* r4300, unsigned int address);
diff --git a/src/device/rcp/pi/pi_controller.c b/src/device/rcp/pi/pi_controller.c
index 31b3473b..f0d5dfef 100644
--- a/src/device/rcp/pi/pi_controller.c
+++ b/src/device/rcp/pi/pi_controller.c
@@ -28,7 +28,6 @@
 #include "api/callbacks.h"
 #include "api/m64p_types.h"
 #include "device/device.h"
-#include "device/dd/dd_controller.h"
 #include "device/memory/memory.h"
 #include "device/r4300/r4300_core.h"
 #include "device/rcp/mi/mi_controller.h"
@@ -61,7 +60,7 @@ static void dma_pi_read(struct pi_controller* pi)
     const struct pi_dma_handler* handler = NULL;
     void* opaque = NULL;
 
+    pi->get_pi_dma_handler(pi->dev, cart_addr, &opaque, &handler);
-    pi->get_pi_dma_handler(pi->cart, pi->dd, cart_addr, &opaque, &handler);
 
     if (handler == NULL) {
         DebugMessage(M64MSG_WARNING, "Unknown PI DMA read: 0x%" PRIX32 " -> 0x%" PRIX32 " (0x%" PRIX32 ")", dram_addr, cart_addr, length);
@@ -90,7 +89,7 @@ static void dma_pi_write(struct pi_controller* pi)
     const struct pi_dma_handler* handler = NULL;
     void* opaque = NULL;
 
+    pi->get_pi_dma_handler(pi->dev, cart_addr, &opaque, &handler);
-    pi->get_pi_dma_handler(pi->cart, pi->dd, cart_addr, &opaque, &handler);
 
     if (handler == NULL) {
         DebugMessage(M64MSG_WARNING, "Unknown PI DMA write: 0x%" PRIX32 " -> 0x%" PRIX32 " (0x%" PRIX32 ")", cart_addr, dram_addr, length);
@@ -111,16 +110,13 @@ static void dma_pi_write(struct pi_controller* pi)
 
 
 void init_pi(struct pi_controller* pi,
+             struct device* dev, pi_dma_handler_getter get_pi_dma_handler,
-             pi_dma_handler_getter get_pi_dma_handler,
-             struct cart* cart,
-             struct dd_controller* dd,
              struct mi_controller* mi,
              struct ri_controller* ri,
              struct rdp_core* dp)
 {
+    pi->dev = dev;
     pi->get_pi_dma_handler = get_pi_dma_handler;
-    pi->cart = cart;
-    pi->dd = dd;
     pi->mi = mi;
     pi->ri = ri;
     pi->dp = dp;
@@ -146,14 +142,6 @@ void write_pi_regs(void* opaque, uint32_t address, uint32_t value, uint32_t mask
 
     switch (reg)
     {
-    case PI_CART_ADDR_REG:
-        if (pi->dd != NULL) {
-            masked_write(&pi->regs[PI_CART_ADDR_REG], value, mask);
-            dd_on_pi_cart_addr_write(pi->dd, pi->regs[PI_CART_ADDR_REG]);
-            return;
-        }
-        break;
-
     case PI_RD_LEN_REG:
         masked_write(&pi->regs[PI_RD_LEN_REG], value, mask);
         dma_pi_read(pi);
@@ -190,13 +178,5 @@ void pi_end_of_dma_event(void* opaque)
 {
     struct pi_controller* pi = (struct pi_controller*)opaque;
     pi->regs[PI_STATUS_REG] &= ~PI_STATUS_DMA_BUSY;
-
-    if (pi->dd != NULL) {
-        if ((pi->regs[PI_CART_ADDR_REG] == MM_DD_C2S_BUFFER) ||
-            (pi->regs[PI_CART_ADDR_REG] == MM_DD_DS_BUFFER)) {
-            dd_update_bm(pi->dd);
-        }
-    }
-
     raise_rcp_interrupt(pi->mi, MI_INTR_PI);
 }
diff --git a/src/device/rcp/pi/pi_controller.h b/src/device/rcp/pi/pi_controller.h
index de2585a7..5ab28332 100644
--- a/src/device/rcp/pi/pi_controller.h
+++ b/src/device/rcp/pi/pi_controller.h
@@ -27,8 +27,7 @@
 
 #include "osal/preproc.h"
 
+struct device;
-struct cart;
-struct dd_controller;
 struct mi_controller;
 struct ri_controller;
 struct rdp_core;
@@ -57,16 +56,15 @@ struct pi_dma_handler
     unsigned int (*dma_write)(void* opaque, uint8_t* dram, uint32_t dram_addr, uint32_t cart_addr, uint32_t length);
 };
 
+typedef void (*pi_dma_handler_getter)(struct device* dev, uint32_t address, void** opaque, const struct pi_dma_handler** handler);
-typedef void (*pi_dma_handler_getter)(struct cart* cart, struct dd_controller* dd, uint32_t address, void** opaque, const struct pi_dma_handler** handler);
 
 struct pi_controller
 {
     uint32_t regs[PI_REGS_COUNT];
 
+    struct device* dev;
     pi_dma_handler_getter get_pi_dma_handler;
 
-    struct cart* cart;
-    struct dd_controller* dd;
     struct mi_controller* mi;
     struct ri_controller* ri;
     struct rdp_core* dp;
@@ -80,9 +78,7 @@ static osal_inline uint32_t pi_reg(uint32_t address)
 
 
 void init_pi(struct pi_controller* pi,
+             struct device* dev, pi_dma_handler_getter get_pi_dma_handler,
-             pi_dma_handler_getter get_pi_dma_handler,
-             struct cart* cart,
-             struct dd_controller* dd,
              struct mi_controller* mi,
              struct ri_controller* ri,
              struct rdp_core* dp);
diff --git a/src/main/main.c b/src/main/main.c
index c4aa1891..77b50463 100644
--- a/src/main/main.c
+++ b/src/main/main.c
@@ -961,137 +961,6 @@ static void open_eep_file(struct file_storage* fstorage)
     }
 }
 
-static void load_dd_rom(uint8_t* rom, size_t* rom_size)
-{
-    /* ask the core loader for DD disk filename */
-    char* dd_ipl_rom_filename = (g_media_loader.get_dd_rom == NULL)
-        ? NULL
-        : g_media_loader.get_dd_rom(g_media_loader.cb_data);
-
-    if ((dd_ipl_rom_filename == NULL) || (strlen(dd_ipl_rom_filename) == 0)) {
-        goto no_dd;
-    }
-
-    struct file_storage dd_rom;
-    memset(&dd_rom, 0, sizeof(dd_rom));
-
-    if (open_rom_file_storage(&dd_rom, dd_ipl_rom_filename) != file_ok) {
-        DebugMessage(M64MSG_ERROR, "Failed to load DD IPL ROM: %s. Disabling 64DD", dd_ipl_rom_filename);
-        goto no_dd;
-    }
-
-    DebugMessage(M64MSG_INFO, "DD IPL ROM: %s", dd_ipl_rom_filename);
-
-    /* load and swap DD IPL ROM */
-    *rom_size = g_ifile_storage_ro.size(&dd_rom);
-    memcpy(rom, g_ifile_storage_ro.data(&dd_rom), *rom_size);
-    close_file_storage(&dd_rom);
-
-    /* fetch 1st word to identify IPL ROM format */
-    /* FIXME: use more robust ROM detection heuristic - do the same for regular ROMs */
-    uint32_t pi_bsd_dom1_config = 0
-        | ((uint32_t)rom[0] << 24)
-        | ((uint32_t)rom[1] << 16)
-        | ((uint32_t)rom[2] <<  8)
-        | ((uint32_t)rom[3] <<  0);
-
-    switch (pi_bsd_dom1_config)
-    {
-    case 0x80270740: /* Z64 - big endian */
-        to_big_endian_buffer(rom, 4, *rom_size/4);
-        break;
-
-    case 0x40072780: /* N64 - little endian */
-        to_little_endian_buffer(rom, 4, *rom_size/4);
-        break;
-
-    case 0x27804007: /* V64 - bi-endian */
-        swap_buffer(rom, 2, *rom_size/2);
-        break;
-
-    default: /* unknown */
-        DebugMessage(M64MSG_ERROR, "Invalid DD IPL ROM: Disabling 64DD.");
-        *rom_size = 0;
-        return;
-    }
-
-    return;
-
-no_dd:
-    free(dd_ipl_rom_filename);
-    *rom_size = 0;
-}
-
-static void load_dd_disk(struct file_storage* dd_disk, const struct storage_backend_interface** dd_idisk)
-{
-    const char* format_desc;
-    /* ask the core loader for DD disk filename */
-    char* dd_disk_filename = (g_media_loader.get_dd_disk == NULL)
-        ? NULL
-        : g_media_loader.get_dd_disk(g_media_loader.cb_data);
-
-    /* handle the no disk case */
-    if (dd_disk_filename == NULL || strlen(dd_disk_filename) == 0) {
-        goto no_disk;
-    }
-
-    /* open file */
-    if (open_rom_file_storage(dd_disk, dd_disk_filename) != file_ok) {
-        DebugMessage(M64MSG_ERROR, "Failed to load DD Disk: %s.", dd_disk_filename);
-        goto no_disk;
-    }
-
-    /* FIXME: handle byte swapping */
-
-
-    switch (dd_disk->size)
-    {
-    case MAME_FORMAT_DUMP_SIZE:
-        /* already in a compatible format */
-        *dd_idisk = &g_ifile_storage;
-        format_desc = "MAME";
-        break;
-
-    case SDK_FORMAT_DUMP_SIZE: {
-        /* convert to mame format */
-        uint8_t* buffer = malloc(MAME_FORMAT_DUMP_SIZE);
-        if (buffer == NULL) {
-            DebugMessage(M64MSG_ERROR, "Failed to allocate memory for MAME disk dump");
-            close_file_storage(dd_disk);
-            goto no_disk;
-        }
-
-        dd_convert_to_mame(buffer, dd_disk->data);
-        free(dd_disk->data);
-        dd_disk->data = buffer;
-        dd_disk->size = MAME_FORMAT_DUMP_SIZE;
-        *dd_idisk = &g_ifile_storage_dd_sdk_dump;
-        format_desc = "SDK";
-        } break;
-
-    default:
-        DebugMessage(M64MSG_ERROR, "Invalid DD Disk size %u.", dd_disk->size);
-        close_file_storage(dd_disk);
-        goto no_disk;
-    }
-
-    DebugMessage(M64MSG_INFO, "DD Disk: %s - %zu - %s",
-            dd_disk->filename,
-            dd_disk->size,
-            format_desc);
-
-    uint32_t w = *(uint32_t*)dd_disk->data;
-    if (w == DD_REGION_JP || w == DD_REGION_US) {
-        DebugMessage(M64MSG_WARNING, "Loading a saved disk ");
-    }
-
-    return;
-
-no_disk:
-    free(dd_disk_filename);
-    *dd_idisk = NULL;
-}
-
 
 struct gb_cart_data
 {
@@ -1244,8 +1113,6 @@ m64p_error main_run(void)
     struct file_storage eep;
     struct file_storage fla;
     struct file_storage sra;
-    size_t dd_rom_size;
-    struct file_storage dd_disk;
 
     int control_ids[GAME_CONTROLLERS_COUNT];
     struct controller_input_compat cin_compats[GAME_CONTROLLERS_COUNT];
@@ -1333,17 +1200,6 @@ m64p_error main_run(void)
     open_fla_file(&fla);
     open_sra_file(&sra);
 
-    /* Load 64DD IPL ROM and Disk */
-    const struct clock_backend_interface* dd_rtc_iclock = NULL;
-    const struct storage_backend_interface* dd_idisk = NULL;
-    memset(&dd_disk, 0, sizeof(dd_disk));
-
-    load_dd_rom((uint8_t*)mem_base_u32(g_mem_base, MM_DD_ROM), &dd_rom_size);
-    if (dd_rom_size > 0) {
-        dd_rtc_iclock = &g_iclock_ctime_plus_delta;
-        load_dd_disk(&dd_disk, &dd_idisk);
-    }
-
     /* setup pif channel devices */
     void* joybus_devices[PIF_CHANNELS_COUNT];
     const struct joybus_device_interface* ijoybus_devices[PIF_CHANNELS_COUNT];
@@ -1480,10 +1336,7 @@ m64p_error main_run(void)
                 &eep, &g_ifile_storage,
                 flashram_type,
                 &fla, &g_ifile_storage,
+                &sra, &g_ifile_storage);
-                &sra, &g_ifile_storage,
-                NULL, dd_rtc_iclock,
-                dd_rom_size,
-                &dd_disk, dd_idisk);
 
     // Attach rom to plugins
     if (!gfx.romOpen())
@@ -1554,7 +1407,6 @@ m64p_error main_run(void)
     close_file_storage(&fla);
     close_file_storage(&eep);
     close_file_storage(&mpk);
-    close_file_storage(&dd_disk);
 
     if (ConfigGetParamBool(g_CoreConfig, "OnScreenDisplay"))
     {
@@ -1590,7 +1442,6 @@ m64p_error main_run(void)
     close_file_storage(&fla);
     close_file_storage(&eep);
     close_file_storage(&mpk);
-    close_file_storage(&dd_disk);
 
     return M64ERR_PLUGIN_FAIL;
 }
diff --git a/src/main/savestates.c b/src/main/savestates.c
index 6ce1c020..b40d464e 100644
--- a/src/main/savestates.c
+++ b/src/main/savestates.c
@@ -60,10 +60,8 @@
 enum { GB_CART_FINGERPRINT_SIZE = 0x1c };
 enum { GB_CART_FINGERPRINT_OFFSET = 0x134 };
 
-enum { DD_DISK_ID_OFFSET = 0x43670 };
-
 static const char* savestate_magic = "M64+SAVE";
+static const int savestate_latest_version = 0x00010300;  /* 1.3 */
-static const int savestate_latest_version = 0x00010400;  /* 1.4 */
 static const unsigned char pj64_magic[4] = { 0xC8, 0xA6, 0xD8, 0x23 };
 
 static savestates_job job = savestates_job_nothing;
@@ -741,53 +739,6 @@ static int savestates_load_m64p(struct device* dev, char *filepath)
             dev->rdram.regs[i][RDRAM_ADDR_SELECT_REG]  = GETDATA(curr, uint32_t);
             dev->rdram.regs[i][RDRAM_DEVICE_MANUF_REG] = GETDATA(curr, uint32_t);
         }
-
-        if (version >= 0x00010400) {
-            /* verify if DD data is present (and matches what's currently loaded) */
-            uint32_t disk_id = GETDATA(curr, uint32_t);
-
-            uint32_t* current_disk_id = ((dev->dd.rom_size > 0) && dev->dd.idisk != NULL)
-                ? (uint32_t*)(dev->dd.idisk->data(dev->dd.disk) + DD_DISK_ID_OFFSET)
-                : NULL;
-
-            if (current_disk_id != NULL && *current_disk_id == disk_id) {
-                dev->dd.regs[DD_ASIC_DATA] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_MISC_REG] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_CMD_STATUS] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_CUR_TK] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_BM_STATUS_CTL] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_ERR_SECTOR] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_SEQ_STATUS_CTL] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_CUR_SECTOR] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_HARD_RESET] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_C1_S0] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_HOST_SECBYTE] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_C1_S2] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_SEC_BYTE] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_C1_S4] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_C1_S6] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_CUR_ADDR] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_ID_REG] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_TEST_REG] = GETDATA(curr, uint32_t);
-                dev->dd.regs[DD_ASIC_TEST_PIN_SEL] = GETDATA(curr, uint32_t);
-
-                /* C2S buffer is expected to be always zero */
-                memset(dev->dd.c2s_buf, 0, 0x400);
-                COPYARRAY(dev->dd.ds_buf, curr, uint8_t, 0x100);
-                COPYARRAY(dev->dd.ms_ram, curr, uint8_t, 0x40);
-
-                dev->dd.rtc.now = (time_t)GETDATA(curr, int64_t);
-                dev->dd.rtc.last_update_rtc = (time_t)GETDATA(curr, int64_t);
-                dev->dd.bm_write = (unsigned char)GETDATA(curr, uint32_t);
-                dev->dd.bm_reset_held = (unsigned char)GETDATA(curr, uint32_t);
-                dev->dd.bm_block = (unsigned char)GETDATA(curr, uint32_t);
-                dev->dd.bm_zone = GETDATA(curr, unsigned int);
-                dev->dd.bm_track_offset = GETDATA(curr, unsigned int);
-            }
-            else {
-                curr += (3+DD_ASIC_REGS_COUNT)*sizeof(uint32_t) + 0x100 + 0x40 + 2*sizeof(int64_t) + 2*sizeof(unsigned int);
-            }
-        }
     }
     else {
         /* extra ai state */
@@ -844,11 +795,6 @@ static int savestates_load_m64p(struct device* dev, char *filepath)
             memcpy(dev->rdram.regs[i], dev->rdram.regs[0], RDRAM_REGS_COUNT*sizeof(dev->rdram.regs[0][0]));
             dev->rdram.regs[i][RDRAM_DEVICE_ID_REG] = ri_address_to_id_field(i * 0x200000) << 2;
         }
-
-        /* dd state */
-        if (dev->dd.rom_size > 0 && dev->dd.idisk != NULL) {
-            poweron_dd(&dev->dd);
-        }
     }
 
     /* Zilmar-Spec plugin expect a call with control_id = -1 when RAM processing is done */
@@ -1200,11 +1146,6 @@ static int savestates_load_pj64(struct device* dev,
         dev->rdram.regs[i][RDRAM_DEVICE_ID_REG] = ri_address_to_id_field(i * 0x200000) << 2;
     }
 
-    /* dd state */
-    if (dev->dd.rom_size > 0 && dev->dd.idisk != NULL) {
-        poweron_dd(&dev->dd);
-    }
-
     savestates_load_set_pc(&dev->r4300, *r4300_cp0_last_addr(&dev->r4300.cp0));
 
     // assert(savestateData+savestateSize == curr)
@@ -1758,49 +1699,6 @@ static int savestates_save_m64p(const struct device* dev, char *filepath)
         PUTDATA(curr, uint32_t, dev->rdram.regs[i][RDRAM_DEVICE_MANUF_REG]);
     }
 
-    uint32_t* disk_id = ((dev->dd.rom_size > 0) && dev->dd.idisk != NULL)
-        ? (uint32_t*)(dev->dd.idisk->data(dev->dd.disk) + DD_DISK_ID_OFFSET)
-        : NULL;
-
-    if (disk_id == NULL) {
-        PUTDATA(curr, uint32_t, 0);
-        curr += (3+DD_ASIC_REGS_COUNT)*sizeof(uint32_t) + 0x100 + 0x40 + 2*sizeof(int64_t) + 2*sizeof(unsigned int);
-    }
-    else {
-        PUTDATA(curr, uint32_t, *disk_id);
-
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_DATA]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_MISC_REG]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_CMD_STATUS]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_CUR_TK]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_BM_STATUS_CTL]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_ERR_SECTOR]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_SEQ_STATUS_CTL]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_CUR_SECTOR]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_HARD_RESET]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_C1_S0]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_HOST_SECBYTE]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_C1_S2]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_SEC_BYTE]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_C1_S4]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_C1_S6]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_CUR_ADDR]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_ID_REG]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_TEST_REG]);
-        PUTDATA(curr, uint32_t, dev->dd.regs[DD_ASIC_TEST_PIN_SEL]);
-
-        PUTARRAY(dev->dd.ds_buf, curr, uint8_t, 0x100);
-        PUTARRAY(dev->dd.ms_ram, curr, uint8_t, 0x40);
-
-        PUTDATA(curr, int64_t, (int64_t)dev->dd.rtc.now);
-        PUTDATA(curr, int64_t, (int64_t)dev->dd.rtc.last_update_rtc);
-        PUTDATA(curr, uint32_t, dev->dd.bm_write);
-        PUTDATA(curr, uint32_t, dev->dd.bm_reset_held);
-        PUTDATA(curr, uint32_t, dev->dd.bm_block);
-        PUTDATA(curr, unsigned int, dev->dd.bm_zone);
-        PUTDATA(curr, unsigned int, dev->dd.bm_track_offset);
-    }
-
     init_work(&save->work, savestates_save_m64p_work);
     queue_work(&save->work);
 
diff --git a/src/plugin/plugin.c b/src/plugin/plugin.c
index b78dda79..14acfb08 100644
--- a/src/plugin/plugin.c
+++ b/src/plugin/plugin.c
@@ -22,7 +22,6 @@
 
 #include <stdint.h>
 #include <stdlib.h>
-#include <string.h>
 
 #include "api/callbacks.h"
 #include "api/m64p_common.h"
@@ -228,25 +227,8 @@ static m64p_error plugin_connect_gfx(m64p_dynlib_handle plugin_handle)
 
 static m64p_error plugin_start_gfx(void)
 {
-    uint8_t media = *((uint8_t*)mem_base_u32(g_mem_base, MM_CART_ROM) + (0x3b ^ S8));
-
-    /* Here we feed 64DD IPL ROM header to GFX plugin if 64DD is present.
-     * We use g_media_loader.get_dd_rom to detect 64DD presence
-     * instead of g_dev because the latter is not yet initialized at plugin_start time */
-    /* XXX: Not sure it is the best way to convey which game is being played to the GFX plugin
-     * as 64DD IPL is the same for all 64DD games... */
-    char* dd_ipl_rom_filename = (g_media_loader.get_dd_rom == NULL)
-        ? NULL
-        : g_media_loader.get_dd_rom(g_media_loader.cb_data);
-
-    uint32_t rom_base = (dd_ipl_rom_filename != NULL && strlen(dd_ipl_rom_filename) != 0 && media != 'C')
-        ? MM_DD_ROM
-        : MM_CART_ROM;
-
-    free(dd_ipl_rom_filename);
-
     /* fill in the GFX_INFO data structure */
+    gfx_info.HEADER = (unsigned char *)mem_base_u32(g_mem_base, MM_CART_ROM);
-    gfx_info.HEADER = (unsigned char *)mem_base_u32(g_mem_base, rom_base);
     gfx_info.RDRAM = (unsigned char *)mem_base_u32(g_mem_base, MM_RDRAM_DRAM);
     gfx_info.DMEM = (unsigned char *)mem_base_u32(g_mem_base, MM_RSP_MEM);
     gfx_info.IMEM = (unsigned char *)mem_base_u32(g_mem_base, MM_RSP_MEM + 0x1000);
