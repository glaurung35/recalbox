--- ppsspp/Common/KeyMap.cpp.orig	2020-05-28 21:44:42.721537142 +0200
+++ ppsspp/Common/KeyMap.cpp	2020-05-28 21:45:39.901099549 +0200
@@ -685,6 +685,7 @@
 	{VIRTKEY_SAVE_STATE, "Save State"},
 	{VIRTKEY_LOAD_STATE, "Load State"},
 	{VIRTKEY_NEXT_SLOT,  "Next Slot"},
+	{VIRTKEY_PREVIOUS_SLOT,  "Previous Slot"},
 #if !defined(MOBILE_DEVICE)
 	{VIRTKEY_TOGGLE_FULLSCREEN, "Toggle Fullscreen"},
 #endif
--- ppsspp/Common/KeyMap.h.orig	2020-05-28 21:45:51.705009247 +0200
+++ ppsspp/Common/KeyMap.h	2020-05-28 21:46:37.912655899 +0200
@@ -61,6 +61,7 @@
 	VIRTKEY_OPENCHAT = 0x4000001D,
 	VIRTKEY_ANALOG_ROTATE_CW = 0x4000001E,
 	VIRTKEY_ANALOG_ROTATE_CCW = 0x4000001F,
+	VIRTKEY_PREVIOUS_SLOT = 0x40000020,
 	VIRTKEY_LAST,
 	VIRTKEY_COUNT = VIRTKEY_LAST - VIRTKEY_FIRST
 };
--- ppsspp/Core/SaveState.cpp.orig	2020-05-28 22:19:22.077226611 +0200
+++ ppsspp/Core/SaveState.cpp	2020-05-28 22:01:11.058000065 +0200
@@ -431,6 +431,11 @@
 		g_Config.iCurrentStateSlot = (g_Config.iCurrentStateSlot + 1) % NUM_SLOTS;
 	}
 
+	void PreviousSlot()
+	{
+		g_Config.iCurrentStateSlot = (g_Config.iCurrentStateSlot - 1) % NUM_SLOTS;
+	}
+
 	void LoadSlot(const std::string &gameFilename, int slot, Callback callback, void *cbUserData)
 	{
 		std::string fn = GenerateSaveSlotFilename(gameFilename, slot, STATE_EXTENSION);
--- ppsspp/Core/SaveState.h.orig	2020-05-28 21:48:48.191660560 +0200
+++ ppsspp/Core/SaveState.h	2020-05-28 21:49:02.383552196 +0200
@@ -41,6 +41,7 @@
 
 	// Cycle through the 5 savestate slots
 	void NextSlot();
+	void PreviousSlot();
 	void SaveSlot(const std::string &gameFilename, int slot, Callback callback, void *cbUserData = 0);
 	void LoadSlot(const std::string &gameFilename, int slot, Callback callback, void *cbUserData = 0);
 	bool UndoSaveSlot(const std::string &gameFilename, int slot);
--- ppsspp/SDL/SDLJoystick.cpp.orig	2020-05-28 22:20:53.860397353 +0200
+++ ppsspp/SDL/SDLJoystick.cpp	2020-05-28 21:58:59.347002527 +0200
@@ -5,9 +5,15 @@
 
 #include <iostream>
 #include <string>
+#include <algorithm>
+#include <sstream>
 
 using namespace std;
 
+static bool hotkey = false;
+static bool hotkeyIsNotADedicatedKey = false;
+keycode_t guideCode;
+
 static int SDLJoystickEventHandlerWrapper(void* userdata, SDL_Event* event)
 {
 	static_cast<SDLJoystick *>(userdata)->ProcessInput(*event);
@@ -46,6 +52,10 @@
 	}
 	if (controllers.size() > 0) {
 		cout << "pad 1 has been assigned to control pad: " << SDL_GameControllerName(controllers.front()) << endl;
+		auto mapping = SDL_GameControllerMapping(controllers.front());
+		// Check with mapping if guide and select have the same button, and turn on a flag
+		guideCode = findGuideRealButton(mapping);
+		hotkeyIsNotADedicatedKey = ( guideCode != NKCODE_UNKNOWN );
 	}
 }
 
@@ -146,7 +156,12 @@
 				key.flags = KEY_DOWN;
 				key.keyCode = code;
 				key.deviceId = DEVICE_ID_PAD_0 + getDeviceIndex(event.cbutton.which);
+				keysPressedCombo.push_back(code);
 				NativeKey(key);
+				if (hotkeyIsNotADedicatedKey and (code == guideCode)) {
+					key.keyCode = NKCODE_BACK;
+					NativeKey(key);
+				}
 			}
 		}
 		break;
@@ -159,6 +174,10 @@
 				key.keyCode = code;
 				key.deviceId = DEVICE_ID_PAD_0 + getDeviceIndex(event.cbutton.which);
 				NativeKey(key);
+				if (code == NKCODE_BUTTON_9 and hotkeyIsNotADedicatedKey) {
+					key.keyCode = NKCODE_BACK;
+					NativeKey(key);
+				}
 			}
 		}
 		break;
@@ -189,6 +208,10 @@
 		setUpController(event.cdevice.which);
 		if (prevNumControllers == 0 && controllers.size() > 0) {
 			cout << "pad 1 has been assigned to control pad: " << SDL_GameControllerName(controllers.front()) << endl;
+			auto mapping = SDL_GameControllerMapping(controllers.front());
+			// Check with mapping if guide and select have the same button, and turn on a flag
+			guideCode = findGuideRealButton(mapping);
+			hotkeyIsNotADedicatedKey = ( guideCode != NKCODE_UNKNOWN );
 		}
 		break;
 	}
@@ -202,3 +225,29 @@
 	}
 	return it->second;
 }
+
+// Hack for people whose HK is not a dedicated button
+keycode_t SDLJoystick::findGuideRealButton(const char* mapping) {
+	std::string s, guideStringCode, guideString;
+	std::istringstream f(mapping);
+	size_t pos;
+
+	while (getline(f, s, ',')) {
+		if (pos=s.find("guide:b") != std::string::npos) {
+			guideString = s;
+			guideStringCode = s.substr(7); // thats length of guide:b
+			break;
+		}
+	}
+
+	s.clear();
+	while (getline(f, s, ',')) {
+		if (pos=s.find(guideStringCode) != std::string::npos and s != guideString) {
+			s = s.substr(0, s.find(':'));
+			if (pos=s.find("back") != std::string::npos) { return NKCODE_BUTTON_9; }
+			if (pos=s.find("leftstick") != std::string::npos) { return NKCODE_BUTTON_THUMBL; }
+			if (pos=s.find("rightstick") != std::string::npos) { return NKCODE_BUTTON_THUMBR; }
+		}
+	}
+	return NKCODE_UNKNOWN;
+}
--- ppsspp/SDL/SDLJoystick.h.orig	2020-05-28 22:01:22.141915719 +0200
+++ ppsspp/SDL/SDLJoystick.h	2020-05-28 22:02:30.865392772 +0200
@@ -28,4 +28,7 @@
 	bool registeredAsEventHandler;
 	std::vector<SDL_GameController *> controllers;
 	std::map<int, int> controllerDeviceMap;
+	std::vector<keycode_t> keysPressedCombo;
+	bool checkGuideCombo();
+	keycode_t findGuideRealButton(const char* mapping);
 };
--- ppsspp/UI/EmuScreen.cpp.orig	2020-05-28 22:09:02.906410588 +0200
+++ ppsspp/UI/EmuScreen.cpp	2020-05-28 22:15:42.831301073 +0200
@@ -95,6 +95,7 @@
 static bool frameStep_;
 static int lastNumFlips;
 static bool startDumping;
+static bool hkPressed;
 
 extern bool g_TakeScreenshot;
 
@@ -536,7 +537,7 @@
 		break;
 
 	case VIRTKEY_PAUSE:
-		pauseTrigger_ = true;
+		hkPressed = true;
 		break;
 
 	case VIRTKEY_FRAME_ADVANCE:
@@ -634,6 +635,10 @@
 		SaveState::NextSlot();
 		NativeMessageReceived("savestate_displayslot", "");
 		break;
+	case VIRTKEY_PREVIOUS_SLOT:
+		SaveState::PreviousSlot();
+		NativeMessageReceived("savestate_displayslot", "");
+		break;
 	case VIRTKEY_TOGGLE_FULLSCREEN:
 		System_SendMessage("toggle_fullscreen", "");
 		break;
@@ -738,11 +743,63 @@
 		__CtrlSetAnalogY(0.0f, 0);
 		break;
 
+	case VIRTKEY_PAUSE:
+		hkPressed = false;
+		break;
+
 	default:
 		break;
 	}
 }
 
+bool EmuScreen::checkCombos(u32 buttons) {
+	if (!hkPressed) {
+		ILOG("HK not pressed");
+		return false;
+	}
+
+	bool retval = false;
+
+	if (buttons & CTRL_CROSS) {
+		pauseTrigger_ = true;
+		retval =  true;
+	}
+	if (buttons & CTRL_START) {
+		System_SendMessage("finish", "");
+		retval =  true;
+	}
+	if (buttons & CTRL_CIRCLE) {
+		sendMessage("reset", "");
+		retval =  true;
+	}
+	if (buttons & CTRL_SQUARE) {
+		onVKeyDown(VIRTKEY_SAVE_STATE);
+		retval =  true;
+	}
+	if (buttons & CTRL_TRIANGLE) {
+		onVKeyDown(VIRTKEY_LOAD_STATE);
+		retval =  true;
+	}
+	if (buttons & CTRL_UP) {
+		onVKeyDown(VIRTKEY_NEXT_SLOT);
+		retval =  true;
+	}
+	if (buttons & CTRL_DOWN) {
+		onVKeyDown(VIRTKEY_PREVIOUS_SLOT);
+		retval =  true;
+	}
+	if (buttons & CTRL_LEFT) {
+		onVKeyDown(VIRTKEY_REWIND);
+		retval =  true;
+	}
+	if (buttons & CTRL_RIGHT) {
+		onVKeyDown(VIRTKEY_SPEED_TOGGLE);
+		retval =  true;
+	}
+	hkPressed = false;
+	return retval;
+}
+
 // Handles control rotation due to internal screen rotation.
 static void SetPSPAxis(char axis, float value, int stick) {
 	switch (g_Config.iInternalScreenRotation) {
@@ -856,8 +913,9 @@
 		}
 	} else {
 		// ILOG("pspKey %i %i", pspKeyCode, flags);
-		if (flags & KEY_DOWN)
-			__CtrlButtonDown(pspKeyCode);
+		if (flags & KEY_DOWN) {
+			if (! checkCombos(pspKeyCode)) __CtrlButtonDown(pspKeyCode);
+		}
 		if (flags & KEY_UP)
 			__CtrlButtonUp(pspKeyCode);
 	}
--- ppsspp/UI/EmuScreen.h.orig	2020-05-28 22:16:06.579068725 +0200
+++ ppsspp/UI/EmuScreen.h	2020-05-28 22:16:54.458606465 +0200
@@ -65,6 +65,7 @@
 	void pspKey(int pspKeyCode, int flags);
 	void onVKeyDown(int virtualKeyCode);
 	void onVKeyUp(int virtualKeyCode);
+	bool checkCombos(u32 buttons);
 	void setVKeyAnalogX(int stick, int virtualKeyMin, int virtualKeyMax);
 	void setVKeyAnalogY(int stick, int virtualKeyMin, int virtualKeyMax);
 
