#!/usr/bin/python
# SPDX-License-Identifier: LGPL-2.1-or-later

from __future__ import absolute_import, print_function, unicode_literals

import time
from threading import Thread, Lock, Timer
import logging
import json
import sys
import dbus
import dbus.mainloop.glib

try:
    from gi.repository import GObject
except ImportError:
    import gobject as GObject

try:
    import paho.mqtt.client as mqtt

    MQTT_AVAILABLE = True
except ImportError:
    MQTT_AVAILABLE = False

import bluezutils

APPNAME = "autopair"

devices = {}
threads = {}
mutex = Lock()


def init_logger():
    """initialize the logger"""
    _logger = logging.getLogger(APPNAME)
    log_formatter = logging.Formatter(
        "%(asctime)s [%(name)-12.12s]:[%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s"
    )
    _logger.setLevel(logging.NOTSET)

    file_handler = logging.FileHandler("/var/log/recalbox-bluetooth.log")
    file_handler.setFormatter(log_formatter)
    file_handler.setLevel(logging.INFO)
    _logger.addHandler(file_handler)

    _logger.setLevel(logging.INFO)
    return _logger


def mqtt_client_connect(client, broker, port, keepalive=60):
    while True:
        logger.info("connecting to mqtt broker %s:%d", broker, port)

        try:
            client.connect(broker, port, keepalive)
            logger.info("connected to mqtt broker")
            client.subscribe("bluetooth/operation")
            client.loop_forever()
        except ConnectionRefusedError:
            logging.error("mqtt connection refused, trying again in 2 seconds")
        except RuntimeError as err:
            logging.error("mqtt connection failed: %s", err)

        time.sleep(2)


def on_mqtt_message(mqtt_client, userdata, message):
    logger.info("message received from broker")
    try:
        data = json.loads(str(message.payload.decode("utf-8")))
        if data["command"] == "start_discovery" and not is_discovering:
            start_discovery()
            # automatically stop autopair discovery after 300 seconds
            stop_discovery_timer = Timer(300.0, stop_discovery)
            stop_discovery_timer.start()
        if data["command"] == "stop_discovery" and is_discovering:
            stop_discovery()
        if data["command"] == "report_status":
            report_status()
    except RuntimeError as err:
        logger.error("error processing message: %s", err)

    logger.info("end of processing mqtt message")


def report_status():
    global is_discovering
    with mutex:
        mqtt_client.publish(
            "bluetooth/status",
            json.dumps({"threads": threads, "is_discovering": is_discovering}),
        )


def start_discovery():
    global is_discovering
    if is_discovering is False:
        is_discovering = True
        logger.info("starting discovery")
        try:
            adapter.StartDiscovery()
        except dbus.exceptions.DBusException as err:
            logger.error("can't start discovery: %s", err)


def stop_discovery():
    global is_discovering
    if is_discovering is True:
        is_discovering = False
        logger.info("stopping discovery")
        try:
            adapter.StopDiscovery()
        except dbus.exceptions.DBusException as err:
            logger.error("can't start discovery: %s", err)


def remove_device(address):
    try:
        logger.info("removing device %s", address)
        device = bluezutils.find_device(address)
        adapter.RemoveDevice(device)
    except Exception as e:
        logger.error("can't remove device %s: %s", address, e)


def pair_device(address):
    try:
        #stop_discovery()
        device = bluezutils.find_device(address)
        device.Pair()
    except Exception as e:
        logger.error("can't pair device %s: %s", address, e)
    #start_discovery()


def trust_bt_device(path):
    btprops = dbus.Interface(
        bus.get_object("org.bluez", path), "org.freedesktop.DBus.Properties"
    )
    return btprops.Set("org.bluez.Device1", "Trusted", True)


def connect_device(address):
    try:
        #stop_discovery()
        device = bluezutils.find_device(address)
    except dbus.exceptions.DBusException as err:
        logger.error("connection to device %s could not start: %s", address, err)
        #start_discovery()
        return
    except Exception as err:
        # device may have been removed elsewhere
        logger.warning("connection to device %s ended in error: %s", address, err)
        return

    tries = 5
    while tries > 0:
        try:
            logger.info("connect %s", address)
            device.Connect()
            logger.info("connection to %s successfull", address)
            #start_discovery()
            return
        except dbus.exceptions.DBusException as err:
            logger.warning("error connecting to %s: %s", address, err)
            time.sleep(1)
        tries = tries - 1

    logger.error("connection to %s failed", address)
    #start_discovery()


def connect_new_device(path, props, pairing_mode: bool):
    trusted = bool(props["Trusted"])
    paired = bool(props["Paired"])
    connected = bool(props["Connected"])
    device_name = props["Name"]
    device_address = props["Address"]

    if not paired:
        logger.info("device %s not paired", device_name)
        if not connected or pairing_mode:
            logger.info("new device %s found, pairing and connecting (force=%s)...", device_name, pairing_mode)
            threads[device_address]["status"] = "connecting"
            pair_device(device_address)
            threads[device_address]["status"] = "done"

    if not trusted:
        logger.info("device %s not trusted, trusting...", device_name)
        threads[device_address]["status"] = "trusting"
        try:
            trust_bt_device(path)
            threads[device_address]["status"] = "trusted"
        except dbus.exceptions.DBusException as err:
            threads[device_address]["status"] = "trust_error"
            logger.error("can't trust %s: %s", device_address, err)

    if not connected:
        remove_device(device_address)
        logger.info("device %s not connected, connecting...", device_name)
        threads[device_address]["status"] = "connecting"
        connect_device(device_address)

    threads[device_address]["status"] = "done"


def power_on_adapter(adapter_path):
    """power-on one bluetooth adapter"""
    adapter_p = dbus.Interface(adapter_path, "org.freedesktop.DBus.Properties")
    adapter_p.Set("org.bluez.Adapter1", "Powered", True)


def is_joystick(device) -> bool:
    """return true if class of device is joystick or gamepad"""
    if dbus.String("Class") not in device.keys():
        return False
    return bool(device["Class"] & 0x1F0F in (0x504, 0x508))


def global_except_hook(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return

    logger.error("uncaught exception", exc_info=(exc_type, exc_value, exc_traceback))


def interfaces_added(path, interfaces):
    if "org.bluez.Device1" not in interfaces:
        return
    properties = interfaces["org.bluez.Device1"]
    if not properties:
        return

    if path in devices:
        devices[path] = dict(devices[path], **properties)
    else:
        devices[path] = properties

    if "Address" in devices[path] and is_joystick(devices[path]):
        address = devices[path]["Address"]
        with mutex:
            threads[address] = {}
        threads[address]["thread"] = Thread(
            target=connect_new_device,
            args=(path, devices[path], False),
            name=devices[path]["Name"],
        )
        threads[address]["name"] = devices[path]["Name"]
        threads[address]["status"] = "connecting"
        threads[address]["thread"].start()


def properties_changed(interface, changed, invalidated, path):
    if interface != "org.bluez.Device1":
        return

    if is_discovering is False:
        return

    if path in devices:
        devices[path] = dict(devices[path], **changed)
    else:
        devices[path] = changed

    if not is_joystick(devices[path]):
        # not a joystick nor a gamepad, not interested
        return
    if "Name" not in devices[path]:
        devices[path]["Name"] = "unknown"

    # joystick found, try to pair and connect

    # verify that Paired, Connected and Trusted are in the properties
    if (
        dbus.String("Paired") not in devices[path].keys()
        or dbus.String("Connected") not in devices[path].keys()
        or dbus.String("Trusted") not in devices[path].keys()
    ):
        return

    if (
        bool(devices[path]["Paired"]) is False
        or bool(devices[path]["Connected"]) is False
        or bool(devices[path]["Trusted"]) is False
    ):
        address = str(devices[path]["Address"])
        if address in threads and threads[address]["status"] == "done":
            logger.info("thread %s done", threads[address]["name"])
            with mutex:
                del threads[address]
        if address not in threads:
            logger.info("trying to pair with %s (%s)", devices[path]["Name"], address)
            with mutex:
                threads[address] = {}
            threads[address]["thread"] = Thread(
                target=connect_new_device,
                args=(path, devices[path], True),
                name=devices[path]["Name"],
            )
            threads[address]["name"] = devices[path]["Name"]
            threads[address]["status"] = "pending"
            threads[address]["thread"].start()


if __name__ == "__main__":
    logger = init_logger()
    sys.excepthook = global_except_hook
    logger.info("%s starting", APPNAME)
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

    bus = dbus.SystemBus()

    adapter_found = False
    while not adapter_found:
        try:
            adapter = bluezutils.find_adapter()
            adapter_found = True
        except:
            time.sleep(10)

    bus.add_signal_receiver(
        interfaces_added,
        dbus_interface="org.freedesktop.DBus.ObjectManager",
        signal_name="InterfacesAdded",
    )

    bus.add_signal_receiver(
        properties_changed,
        dbus_interface="org.freedesktop.DBus.Properties",
        signal_name="PropertiesChanged",
        arg0="org.bluez.Device1",
        path_keyword="path",
    )

    # check all BT managed items
    om = dbus.Interface(
        bus.get_object("org.bluez", "/"), "org.freedesktop.DBus.ObjectManager"
    )
    objects = om.GetManagedObjects()
    for path, interfaces in objects.items():
        # fill in known gaming devices
        if (
            "org.bluez.Device1" in interfaces
            and is_joystick(interfaces["org.bluez.Device1"])
        ):
            devices[path] = interfaces["org.bluez.Device1"]

        # power-on bt adapters
        if (
            "org.bluez.Adapter1" in interfaces
            and "Powered" in interfaces["org.bluez.Adapter1"]
            and bool(interfaces["org.bluez.Adapter1"]["Powered"]) is False
        ):
            logger.info(
                "powering bluetooth adapter %s on",
                interfaces["org.bluez.Adapter1"]["Address"],
            )
            try:
                power_on_adapter(bus.get_object("org.bluez", path))
            except dbus.exceptions.DBusException as db_err:
                logger.error(
                    "can't power on adapter %s : %s",
                    interfaces["org.bluez.Adapter1"]["Address"],
                    db_err,
                )

    is_discovering = False

    # mqtt_handler
    if MQTT_AVAILABLE:
        mqtt_client = mqtt.Client(APPNAME)
        mqtt_client.on_message = on_mqtt_message
        mqtt_thread = Thread(
            target=mqtt_client_connect,
            args=(mqtt_client, "127.0.0.1", 1883),
            name="mqtt-client",
        )
        mqtt_thread.start()
    else:
        logger.warning("mqtt unavailable")

    mainloop = GObject.MainLoop()
    mainloop.run()
