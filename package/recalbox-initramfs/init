#!/bin/busybox ash
# Check https://github.com/jumperfly/initramfs-overlay/blob/master/src/init

RECALSQUASH=recalbox.squashfs
SHARE_UUID="2eebe1cc-f5f9-4db4-b7d1-21c876760984"

log () {
    echo "(RECALBOX-irfs) $1" >/dev/kmsg
    # Manual tee ...
    echo "(RECALBOX-irfs) $1" >> /new_root/boot/boot.log
}

# Works with /dev/sda1, /dev/mmcblk0p4, /dev/hdd12
# Returns /dev/sda /dev/mmcblk0p /dev/hdd
getDeviceName() {
    echo "$1" | grep -oE "[a-z\/]*([0-9]p)?"
}

# Works with /dev/sda1, /dev/mmcblk0p4, /dev/hdd12
# returns 1 4 12
getPartitionNumber() {
    echo "$1" | grep -oE "[0-9]+$"
}

# Sadly some systems don't give details about the boot partition soon enough,
# so this function is useless to the determine boot method
getRootMethod () {
    # No other choice than relying on the partition name :/
    # NOOBS sets label boot, .img uses BOOT
    # Can't mount with -o ro as we log to /boot. The inittab will remount it as RO 
    mount LABEL=BOOT /new_root/boot || mount LABEL=boot /new_root/boot || echo "" && return

    # Time to read who we shall boot
    while read param ; do
        case ${param} in
            boot=*) boot=${param#boot=} ;;
        esac
    done < /new_root/boot/recalbox-boot.conf
    echo "${boot}"
}

checkValidKernel() {
    # Make sure the the kernel is the one suited for the current boot type
    # If it differs, replace and reboot
    
    log "Checking kernels ..."
    bootType="$1"
    # x86 has its kernel as /boot/boot/bzImage, whereas other boards have it in /boot/zImage
    test -e /new_root/boot/zImage && kernelName="zImage"
    test -e /new_root/boot/boot/bzImage && kernelName="boot/bzImage"
    if test "${bootType}" == "squashfs" -a -e /new_root/defaultroot/${RECALSQUASH}; then
        log "Found a squashfs file + a squashfs specific kernel"
        origKernel="${kernelName}.squashfs"
    else
        log "Couldn't find a squashfs file, or squashfs boot is not set, defaulting to SD"
        origKernel="${kernelName}.sd"
    fi
    if test -e "/new_root/boot/${origKernel}" && ! diff -q "/new_root/boot/zImage" "/new_root/boot/${origKernel}" ; then
        log "Kernels differ between zImage and $origKernel ! Copy the right one and reboot"
        cp "/new_root/boot/${origKernel}" "/new_root/boot/${kernelName}" || log "Copying the kernel failed :/"
        umount -a
        cp /new_root/boot/boot.log /new_root/boot/boot.log.kernelupdate
        /sbin/reboot -f
    fi
    log "Kernels OK (${kernelName} and $origKernel) ! Continuing ..."
}

checkAndUpgradeSquashfs () {
    sFile=/new_root/defaultroot/${RECALSQUASH}
    sUpg=${sFile}.upgrade
    sDowng=${sFile}.downgrade
    test -e ${sUpg} && log "UPGRADE: found /new_root/defaultroot/${RECALSQUASH}.upgrade" || log "UPGRADE: no upgrade available"
    if test -e ${sUpg} ; then
        log "Found an update, renaming versions"
        # The very first upgrade has no .downgrade, so don't fail on the rm
        test -e ${sDowng} && ${sDowng}
        test -e ${sFile} && mv ${sFile} ${sDowng}
        if ! mv ${sUpg} ${sFile} ; then
            # Time to rollback to avoid a boot loop
            log "Upgrade failed :( Restoring previous version"
            rm ${sUpg} || log "Couldn't delete the upgrade"
            mv ${sDowng} ${sFile} || log "Couldn't restore the previous version"
            log "Previous version restored"
            return 1
        fi
        log "Upgrade done"
        return 0
    elif test -e /new_root/defaultroot/${RECALSQUASH} ; then
        log "UPGRADE: squashfs found with no upgrade"
        return 0
    fi
    return 1
}

mount_overlay () {
    upperLayer="$1"
    mkdir -p /mnt/overlay /mnt/lower /mnt/root /mnt/upper
    
    log "Mount squashfs as lower fs"
    mount -t squashfs -r /new_root/defaultroot/${RECALSQUASH} /mnt/lower
    
    log "Mount the upper overlay FS"
    #~ mount "$upperLayer" /mnt/upper || log "Errr ... It failed"
    mount UUID="$SHARE_UUID" /mnt/upper || log "Errr ... It failed"
    
    log "mkdir upper and work"
    for dir in upper work; do
        mkdir -p "/mnt/upper/system/.overlay/$dir"
    done

    # Mount root file system (overlay)
    log "Initializing the overlay"
    mount -t overlay -o ro,lowerdir=/mnt/lower,upperdir=/mnt/upper/system/.overlay/upper,workdir=/mnt/upper/system/.overlay/work overlay /mnt/root && log "Overlay successfully mounted !" || log "Failed to mount the overlay"
    log "Moving sys proc and dev"
    mount --move /sys  /mnt/root/sys  || return 1
    mount --move /proc /mnt/root/proc || return 1
    mount --move /dev  /mnt/root/dev  || return 1
    mount --move /new_root/boot /mnt/root/boot
    log "Overlay ok. Switching root ..."
    exec switch_root /mnt/root /sbin/init
}

mkdir -p /sys /proc /new_root/boot /new_root/defaultroot /new_root/squashfs
mount -t proc -o nodev,noexec,nosuid proc /proc  || return 1
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys || return 1

# read the parameters
read -r cmdline < /proc/cmdline
for param in ${cmdline} ; do
    case ${param} in
        label=*) label=${param#label=};;
        root=*) root=${param#root=};;
        ro) mountRO="-r";;
    esac
done

# look for devices
mount -t devtmpfs none /dev

# PC uses the label, NOOBS uses the root
if test -z "${label}" -a ! -z "${root}" ; then
    # NOOBS case: root=/dev/mmcblk0pn
    toMount="${root}"
elif test -z "${root}" -a ! -z "${label}" ; then
    # PC case: label=RECALBOX
    toMount="LABEL=${label}"
else
    # Failsafe mode, if it's ever needed
    # maybe give a try to /dev/root rather ?
    toMount="LABEL=RECALBOX"
fi

# Find the root method -> /boot is mounted
exec >/dev/kmsg 2>&1
# Log to to /boot only if found
mount LABEL=BOOT /new_root/boot || mount LABEL=boot /new_root/boot && exec >/new_root/boot/boot.log 2>&1
#~ rootMethod=`getRootMethod`

log "Starting new boot log" 
mount ${mountRO} ${toMount} /new_root/defaultroot

log "Mounted: ${toMount} as root source, booting to $rootMethod `[ "$rootMethod" != "squashfs" ] && echo "default"`"
log "`blkid`"
# Mount the squashfs if found
if test -e /new_root/defaultroot/${RECALSQUASH} ; then
    mount_overlay "${toMount}"
else
    log "Squashfs not set or squashfs file not found"
    log "Remounting to the default root device"
    mount --move /sys  /new_root/defaultroot/sys  || return 1
    mount --move /proc /new_root/defaultroot/proc || return 1
    mount --move /dev  /new_root/defaultroot/dev  || return 1
    mount -o remount -r /new_root/boot 2>&1
    mount -o remount -r /new_root/defaultroot 2>&1
    mount --move /new_root/boot /new_root/defaultroot/boot || log "Couldn't move /boot"
    # switch to the old root
    exec switch_root /new_root/defaultroot /sbin/init || return 1
fi
