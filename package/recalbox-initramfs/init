#!/bin/busybox ash
# Check https://github.com/jumperfly/initramfs-overlay/blob/master/src/init

RECALSQUASH=recalbox.squashfs

log () {
    echo "(RECALBOX-irfs) $1" >/dev/kmsg
    # Manual tee ...
    echo "(RECALBOX-irfs) $1" >> /new_root/boot/boot.log
}

getRootMethod () {
    # No other choice than relying on the partition name :/
    # NOOBS sets label boot, .img uses BOOT
    #~ mount -o ro LABEL=BOOT /new_root/boot || return ""
    mount LABEL=BOOT /new_root/boot || mount LABEL=boot /new_root/boot || return ""
    while read param ; do
        case ${param} in
            boot=*) boot=${param#boot=};;
        esac
    done < /new_root/boot/recalbox-boot.conf
    echo "${boot}"
}

checkValidKernel() {
    # Make sure the the kernel is the one suited for the current boot type
    # If it differs, replace and reboot
    
    # Il manque a tester : si mode squashfs mais que pas de squashfs prÃ©sent, on boot en SD
    log "Checking kernels ..."
    bootType="$1"
    if test "${bootType}" == "squashfs" -a -e /new_root/defaultroot/${RECALSQUASH}; then
        log "Found a squashfs file + a squashfs specific kernel"
        origKernel="zImage.squashfs"
    else
        log "Couldn't find a squashfs file, or squashfs boot is not set, defaulting to SD"
        origKernel="zImage.sd"
    fi
    if test -e "/new_root/boot/${origKernel}" && ! diff -q "/new_root/boot/zImage" "/new_root/boot/${origKernel}" ; then
        log "Kernels differ between zImage and $origKernel ! Copy the right one and reboot"
        cp "/new_root/boot/${origKernel}" "/new_root/boot/zImage" || log "Copying the kernel failed :/"
        umount -a
        cp /new_root/boot/boot.log /new_root/boot/boot.log.kernelupdate
        /sbin/reboot -f
    fi
    log "Kernels OK (zImage and $origKernel) ! Continuing ..."
}

checkAndUpgradeSquashfs () {
    bootType="$1"
    test -e /new_root/defaultroot/${RECALSQUASH}.upgrade && log "UPGRADE: found /new_root/defaultroot/${RECALSQUASH}.upgrade" || log "UPGRADE: no upgrade available"
    if test "${bootType}" == "squashfs" -a -e /new_root/defaultroot/${RECALSQUASH}.upgrade ; then
        log "Found an update, renaming versions"
        # The very first upgrade has no .downgrade, so don't fail on the rm
        test -e /new_root/defaultroot/${RECALSQUASH}.downgrade && rm /new_root/defaultroot/${RECALSQUASH}.downgrade
        test -e /new_root/defaultroot/${RECALSQUASH} && mv /new_root/defaultroot/${RECALSQUASH} /new_root/defaultroot/${RECALSQUASH}.downgrade
        if ! mv /new_root/defaultroot/${RECALSQUASH}.upgrade /new_root/defaultroot/${RECALSQUASH} ; then
            # Time to rollback to avoid a boot loop
            log "Upgrade failed :( Restoring previous version"
            rm /new_root/defaultroot/${RECALSQUASH}.upgrade || log "Couldn't delete the upgrade"
            mv /new_root/defaultroot/${RECALSQUASH}.downgrade /new_root/defaultroot/${RECALSQUASH} || log "Couldn't restore the previous version"
            log "Previous version restored"
            return 1
        fi
        log "Upgrade done"
    fi
}

mount_overlay () {
    mkdir -p /mnt/overlay /mnt/lower /mnt/root /mnt/upper
    
    log "Mount squashfs as lower fs"
    mount -t squashfs -r /new_root/defaultroot/${RECALSQUASH} /mnt/lower
    
    log "Mount the upper overlay FS"
    mount LABEL=SHARE /mnt/upper || log "Errr ... It failed"
    
    log "mkdir upper and work"
    for dir in upper work; do
        mkdir -p "/mnt/upper/system/.overlay/$dir"
    done

    # Mount root file system (overlay)
    log "Initializing the overlay"
    mount -t overlay -o ro,lowerdir=/mnt/lower,upperdir=/mnt/upper/system/.overlay/upper,workdir=/mnt/upper/system/.overlay/work overlay /mnt/root && log "Overlay successfully mounted !" || log "Failed to mount the overlay"
    log "Moving sys proc and dev"
    mount --move /sys  /mnt/root/sys  || return 1
    mount --move /proc /mnt/root/proc || return 1
    mount --move /dev  /mnt/root/dev  || return 1
    mount --move /new_root/boot /mnt/root/boot
    log "Overlay ok. Switching root ..."
    exec switch_root /mnt/root /sbin/init
}

do_root() {
    max_delay=5
    
    mkdir -p /sys /proc /new_root/boot /new_root/defaultroot /new_root/squashfs
    mount -t proc -o nodev,noexec,nosuid proc /proc  || return 1
    mount -t sysfs -o nodev,noexec,nosuid sysfs /sys || return 1

    # read the parameters
    read -r cmdline < /proc/cmdline
    for param in ${cmdline} ; do
        case ${param} in
            label=*) label=${param#label=};;
            root=*) root=${param#root=};;
            #ro) mountRO="-r";;
        esac
    done

    # look for devices
    mount -t devtmpfs none /dev
    
    # PC uses the label, NOOBS uses the root
    if test -z "${label}" -a ! -z "${root}" ; then
        # NOOBS case: root=/dev/mmcblk0pn
        toMount="${root}"
    elif test -z "${root}" -a ! -z "${label}" ; then
        # PC case: label=RECALBOX
        toMount="LABEL=${label}"
    else
        # Failsafe mode, if it's ever needed
        # maybe give a try to /dev/root rather ?
        toMount="LABEL=RECALBOX"
    fi
    
    # Find the root method -> /boot is mounted
    rootMethod=`getRootMethod`
    
    # Clean previous logs, redirect output
    rm /new_root/boot/boot.log
    #rm /new_root/boot/boot.log.kernelupdate
    #~ exec >/dev/kmsg 2>&1
    exec >/new_root/boot/boot.log 2>&1

    log "Starting new boot log" 

    timeout=0
    # Can't mount with -r as we need to work on the filesystem for upgrades
    while ! mount ${toMount} /new_root/defaultroot ; do
        log "Waiting for the root device"
        sleep 1
        let "timeout=$timeout + 1"
        test $timeout -gt "5" && return 1
    done
    log "Mounted: ${toMount} as root source, booting to $rootMethod `[ "$rootMethod" != "squashfs" ] && echo "default"`"
    
    # Update available ?
    checkAndUpgradeSquashfs "$rootMethod"
    
    # The upgrade has to be done before we check the squashfs/sd kernel
    checkValidKernel "$rootMethod"
        
    log "Trying to use root from: $rootMethod"

    # Mount the squashfs if found
    if test "${rootMethod}" == "squashfs" -a -e /new_root/defaultroot/${RECALSQUASH} ; then
        mount_overlay && return 0
    fi
    
    # moving current mounts
    return 1
}

if ! do_root
then
    log "Couldn't mount a squashfs"
    log "Remounting to the default root device"
    mount --move /sys  /new_root/defaultroot/sys  || return 1
    mount --move /proc /new_root/defaultroot/proc || return 1
    mount --move /dev  /new_root/defaultroot/dev  || return 1
    mount -o remount -r /new_root/boot 2>&1
    mount --move /new_root/boot /new_root/defaultroot/boot || log "Couldn't move /boot"
    # switch to the old root
    exec switch_root /new_root/defaultroot /sbin/init || return 1
fi
