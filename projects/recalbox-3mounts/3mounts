#!/bin/bash
# This script mounts mass storage devices when they are plugged in
# and unmounts them when they are removed.
# Copyright © 2004, 2005 Martin Dickopp
# Copyright © 2008-2012 Rogério Theodoro de Brito
#             2024 davidb2111
#
# This file is free software; the copyright holder gives unlimited
# permission to copy and/or distribute it, with or without
# modifications, as long as this notice is preserved.
#
# This file is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.
#
set -e
exec > /dev/null 2>&1

######################################################################
# Auxiliary functions

# Log a string via the syslog facility.
log()
{
  if [ $1 != debug ] || expr "$VERBOSE" : "[yY]" > /dev/null; then
    logger -p user.$1 -t "3mounts[$$]" -- "$2"
  fi
}


# Test if the first parameter is in the list given by the second
# parameter.
in_list()
{
  for v in $2; do
    [ "$1" != "$v" ] || return 0
  done
  return 1
}


# Test if the first parameter is in the list given by the second
# parameter.
in_regexp_list()
{
  local RC=1
  for v in $2; do
    [[ "$1" =~ $v ]] && RC=0
  done
  return $RC
}


# $1 directory of mountpoint without the ID
find_first_free_mountpoint()
{
  local S
  S=0
  while grep -q -E "$1$S\b" "/proc/mounts"; do
    S=$((S+1))
  done
  echo "$1$S"
}

######################################################################
# Main program

# Default values for configuration variables.
ENABLED=1
MOUNTPOINTS=
FILESYSTEMS=
MOUNTOPTIONS=
FS_MOUNTOPTIONS=
VERBOSE=no

if [ -r /etc/3mounts/3mounts.conf ]; then
  . /etc/3mounts/3mounts.conf
  log debug "loaded 3mounts configurations"
fi

if [ "${ENABLED:-1}" -eq 0 ]; then
  log info "3mounts is disabled, see /etc/3mounts/3mounts.conf"
  exit 0
fi

# Per Policy 9.3.2, directories under /var/run have to be created
# after every reboot.
if [ ! -e /var/run/3mounts ]; then
  mkdir -p /var/run/3mounts
  log debug "creating /var/run/3mounts directory"
fi

umask 022


if [ "$1" = add ]; then

  # Acquire lock.
  log debug "trying to acquire lock /var/run/3mounts/.mount.lock"
  lockfile-create --retry 3 /var/run/3mounts/.mount || \
    { log err "cannot acquire lock /var/run/3mounts/.mount.lock"; exit 1; }
    trap '( lockfile-remove /var/run/3mounts/.mount )' 0
    log debug "acquired lock /var/run/3mounts/.mount.lock"

  # Query udev for the expected device information (as we are now running in
  # a service's context and the env variables have been lost)
  eval $(udevadm info --query=env --export "$DEVNAME" | grep -v '^[^=]*\..*=')

  if ! echo "$ID_FS_USAGE" | egrep -q "(filesystem|disklabel)"; then
    log info "$DEVNAME does not contain a filesystem or disklabel"
    exit 0
  fi

  # Try to use specifications in /etc/fstab first.
  if egrep -q "^[[:blank:]]*$DEVNAME" /etc/fstab; then
    log info "executing command: mount $DEVNAME"
    mount "$DEVNAME" || log err "mount by DEVNAME with $DEVNAME wasn't successful; return code $?"

  elif grep -q "^[[:blank:]]*UUID=\"?$ID_FS_UUID\"?" /etc/fstab; then
    log info "executing command: mount -U $ID_FS_UUID"
    mount -U "$ID_FS_UUID" || log err "mount by UUID with $ID_FS_UUID wasn't successful; return code $?"

  else
    log debug "$DEVNAME of type $XMOUNTS_TYPE contains filesystem type $ID_FS_TYPE"

    fstype=$ID_FS_TYPE
    # Test if the filesystem type is in the list of filesystem
    # types to mount.
    if in_list "$fstype" "$FILESYSTEMS"; then
      # Search an available mountpoint.
      mountpoint=$(find_first_free_mountpoint "${MOUNTPOINTS[$XMOUNTS_TYPE]}")
      if [ -n "$mountpoint" ]; then
        # Determine mount options.
        options=
        for v in $FS_MOUNTOPTIONS; do
          if expr "$v" : "-fstype=$fstype,."; then
            options="$(echo "$v" | sed 's/^[^,]*,//')"
            break
          fi
        done
        if [ -n "$MOUNTOPTIONS" ]; then
          options="$MOUNTOPTIONS${options:+,$options}"
        fi

        # Mount the filesystem.
        [ ! -d "$mountpoint" ] && mkdir -p "$mountpoint"
        log info "executing command: mount -t$fstype ${options:+-o$options} $DEVNAME $mountpoint"
        mount "-t$fstype" "${options:+-o$options}" "$DEVNAME" "$mountpoint"
      else
        # No suitable mount point found.
        log warning "no mountpoint found for $DEVNAME of type $XMOUNTS_TYPE"
        exit 1
      fi
    fi
  fi
elif [ "$1" = remove ]; then

  # A block or partition device has been removed.
  # Test if it is mounted.
  while read device mountpoint fstype remainder; do
    if [ "$DEVNAME" = "$device" ]; then
      # If the mountpoint and filesystem type are maintained by
      # this script, unmount the filesystem.
      if in_regexp_list "$mountpoint" "${MOUNTPOINTS[@]}" &&
        in_list "$fstype" "$FILESYSTEMS"; then
        log info "executing command: umount -l $mountpoint"
        umount -l "$mountpoint"
      fi
      break
    fi
  done < /proc/mounts
else
  log err "unexpected: action '$1'"
  exit 1
fi

log debug "3mounts execution finished"
